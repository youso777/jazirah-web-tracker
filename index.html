<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Jazirah Club Traffic - OMRJ V2.0</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background-color: #353535;
      font-family: Arial, sans-serif;
      color: white;
    }

    #app {
      display: flex;
      height: 100%;
      width: 100%;
    }

    /* Left menu */
    #sidebar {
      width: 250px;
      background-color: #2a2a2a;
      display: flex;
      flex-direction: column;
      padding: 5px;
      box-sizing: border-box;
    }

    #sidebar .logo {
      text-align: center;
      margin-bottom: 10px;
    }

    #sidebar .logo img {
      max-width: 230px;
      max-height: 80px;
      object-fit: contain;
    }

    #sidebar h3 {
      margin: 10px 0 5px;
      font-size: 14px;
      border-bottom: 1px solid #444;
      padding-bottom: 3px;
    }

    #sidebar label {
      font-size: 13px;
      display: flex;
      align-items: center;
      margin: 3px 0;
    }

    #sidebar input[type="text"] {
      background-color: #333;
      color: white;
      border: 1px solid #555;
      border-radius: 3px;
      padding: 2px 4px;
      width: 60px;
      margin-left: 5px;
    }

    #status-text {
      font-weight: bold;
      font-size: 14px;
      text-align: center;
      margin-top: 5px;
      color: orange;
    }

    #footer {
      font-size: 10px;
      text-align: center;
      color: #888;
      margin-top: auto;
      padding-top: 10px;
      border-top: 1px solid #444;
    }

    /* Map area */
    #map-container {
      flex: 1;
      position: relative;
    }

    #map {
      height: 100%;
      width: 100%;
      background: #000; /* helps hide white seams between tiles */
    }

    /* Also ensure leaflet container is dark behind tiles */
    .leaflet-container {
      background: #000;
    }

    /* Leaflet tooltip style (same as PyQt HTML) */
    .leaflet-tooltip.aircraft-label {
      background: rgba(0,0,0,0.8);
      padding: 4px 6px;
      font-size: 12px;
      font-family: monospace;
      color: #39FF14;
      border: none;
      text-align: center;
      line-height: 1.4;
    }

    .aircraft-label .id {
      display: block;
      font-weight: bold;
      font-size: 14px;
      color: white;
      margin-bottom: 2px;
    }

    /* VRP marker: small cyan triangle + label */
    .vrp-div-icon {
      background: transparent;
      border: none;
    }

    .vrp-div-icon .vrp-triangle {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 10px solid #00ffff; /* cyan triangle */
    }

    .leaflet-tooltip.vrp-label {
      background: rgba(0,0,0,0.7);
      border: none;
      color: #fff;
      font-size: 11px;
      padding: 2px 4px;
    }

    /* Small top-right instructions */
    #help-overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.6);
      padding: 6px 8px;
      font-size: 11px;
      border-radius: 4px;
    }
  </style>
</head>
<body>
<div id="app">
  <!-- Sidebar -->
  <div id="sidebar">
    <div class="logo">
      <img src="jazirah-club.png" alt="Jazirah Club">
    </div>

    <!-- QNH -->
    <h3>QNH Settings</h3>
    <label>
      QNH:
      <input type="text" id="qnh-input" value="1013.25">
    </label>

    <!-- Display options -->
    <h3>Display Options</h3>
    <label><input type="checkbox" id="show-reg" checked> Registration</label>
    <label><input type="checkbox" id="show-spd" checked> Speed</label>
    <label><input type="checkbox" id="show-alt" checked> Altitude</label>
    <label><input type="checkbox" id="show-hdg" checked> Heading</label>
    <label><input type="checkbox" id="show-temp" checked> Temperature</label>
    <!-- Follow-Me checkbox -->
    <label><input type="checkbox" id="follow-me"> Follow-Me</label>
    <!-- Line Tracking checkbox -->
    <label><input type="checkbox" id="show-track"> Line Tracking</label>

    <!-- Status -->
    <h3>Status</h3>
    <div id="status-text">No Signal</div>

    <div id="footer">Jazirah Club V2.0</div>
  </div>

  <!-- Map -->
  <div id="map-container">
    <div id="map"></div>
    <div id="help-overlay">
      Keys: <b>G</b> toggle follow<br/>
      Click red dot or enable "Line Tracking"<br/>
      Data via MQTT over WebSocket
    </div>
  </div>
</div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>

<!-- MQTT.js (browser) -->
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

<script>
  // ========= Map setup =========
  // OMRJ coords
  var airportCoords = [25.6646, 55.7749];
  var map = L.map('map').setView(airportCoords, 16);

  L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { attribution: '© Esri', maxZoom: 18 }
  ).addTo(map);

const vrps = [
  { name: 'Sham Village',          lat: 26.02806,  lon: 56.08639 },   // 26°01'41"N 56°05'11"E
  { name: 'Saqr Port',             lat: 25.97500,  lon: 56.05667 },   // 25°58'30"N 56°03'24"E
  { name: 'Al Rams',               lat: 25.88417,  lon: 56.01139 },   // 25°53'03"N 56°00'41"E
  { name: 'Hilton Beach Hotel',    lat: 25.81444,  lon: 55.95778 },   // 25°48'52"N 55°57'28"E
  { name: 'Clock Roundabout',      lat: 25.76583,  lon: 55.92000 },   // 25°45'57"N 55°55'12"E
  { name: 'Al Cove Rotana',        lat: 25.73750,  lon: 55.88806 },   // 25°44'15"N 55°53'17"E
  { name: 'Emirates Roundabout',   lat: 25.71833,  lon: 55.86139 },   // 25°43'06"N 55°51'41"E
  { name: 'Al Jazirah Al Hamra',   lat: 25.70694,  lon: 55.80278 },   // 25°42'25"N 55°48'10"E
  { name: 'Al Hamra Fort Resort',  lat: 25.68917,  lon: 55.78750 }    // 25°41'21"N 55°47'15"E
];


  const vrpIcon = L.divIcon({
    className: 'vrp-div-icon',
    html: '<div class="vrp-triangle"></div>',
    iconSize: [12, 10],
    iconAnchor: [6, 10]
  });

  vrps.forEach(v => {
    const m = L.marker([v.lat, v.lon], { icon: vrpIcon }).addTo(map);
    m.bindTooltip(v.name, {
      permanent: true,
      direction: 'right',
      className: 'vrp-label',
      offset: [8, 0]
    });
  });

  // ========= Aircraft marker =========
  var dot = L.circleMarker(airportCoords, {
    radius: 6,
    color: 'red',
    fillColor: 'red',
    fillOpacity: 1
  }).addTo(map);

  var label = L.tooltip({
    permanent: true,
    direction: 'right',
    className: 'aircraft-label'
  }).setLatLng(airportCoords).addTo(map);

  // ========= Track line (history) =========
  var trackPoints = []; // list of [lat, lon]
  var trackLine = null; // Leaflet polyline

  function updateTrackVisibility() {
    if (!showTrackBox) return;

    if (showTrackBox.checked && trackPoints.length > 0) {
      // Show or create the track
      if (!trackLine) {
        trackLine = L.polyline(trackPoints, {
          color: 'yellow',
          weight: 3
        }).addTo(map);
      } else if (!map.hasLayer(trackLine)) {
        map.addLayer(trackLine);
      }
    } else {
      // Hide the track
      if (trackLine && map.hasLayer(trackLine)) {
        map.removeLayer(trackLine);
      }
    }
  }

  function addTrackPoint(lat, lon) {
    if (lat === null || lon === null || isNaN(lat) || isNaN(lon)) return;

    // Avoid adding identical consecutive points
    if (
      trackPoints.length === 0 ||
      trackPoints[trackPoints.length - 1][0] !== lat ||
      trackPoints[trackPoints.length - 1][1] !== lon
    ) {
      trackPoints.push([lat, lon]);

      // If track is visible, update it
      if (trackLine && showTrackBox && showTrackBox.checked) {
        trackLine.setLatLngs(trackPoints);
      }
    }
  }

  // Clicking on the red dot toggles "Line Tracking"
  dot.on('click', function () {
    if (!showTrackBox) return;
    if (!trackPoints.length) return;

    // Toggle checkbox
    showTrackBox.checked = !showTrackBox.checked;
    updateTrackVisibility();

    // If we just enabled it, zoom to path
    if (showTrackBox.checked && trackLine) {
      map.fitBounds(trackLine.getBounds(), { padding: [20, 20] });
    }
  });

  // ======================================

  function updateLabel(showReg, showSpd, showAlt, showHdg, showTemp,
                       speed, alt, hdg, tempC) {
    function valOrDash(v, suffix) {
      if (v === null || v === undefined || isNaN(v)) return '—';
      return v + (suffix || '');
    }

    let content = '';
    if (showReg) {
      content += '<span class="id">A6-ALL</span>';
    }
    if (showSpd) {
      content += 'Speed: <span style="color:#39FF14">'
              + valOrDash(speed, ' Kph')
              + '</span><br>';
    }
    if (showAlt) {
      content += 'Alt: <span style="color:#39FF14">'
              + valOrDash(alt, ' ft')
              + '</span><br>';
    }
    if (showHdg) {
      content += 'HDG: <span style="color:#39FF14">'
              + valOrDash(hdg, '°')
              + '</span><br>';
    }
    if (showTemp) {
      content += 'Temp: <span style="color:#39FF14">'
              + valOrDash(tempC, ' °C')
              + '</span>';
    }
    label.setContent(content);
  }

  function setAircraft(lat, lon) {
    if (lat === null || lon === null || isNaN(lat) || isNaN(lon)) return;
    var p = [lat, lon];
    dot.setLatLng(p);
    label.setLatLng(p);
  }

  // ========= Telemetry + UI state =========
  let lastHeading  = null;
  let lastPressure = null;
  let lastTempC    = null;
  let lastSpeed    = null;
  let lastHasGPS   = false;
  let lastLat      = null;
  let lastLon      = null;
  let lastRxTime   = 0;

  let followEnabled = false;

  const qnhInput     = document.getElementById('qnh-input');
  const showRegBox   = document.getElementById('show-reg');
  const showSpdBox   = document.getElementById('show-spd');
  const showAltBox   = document.getElementById('show-alt');
  const showHdgBox   = document.getElementById('show-hdg');
  const showTempBox  = document.getElementById('show-temp');
  const followMeBox  = document.getElementById('follow-me');
  const showTrackBox = document.getElementById('show-track');
  const statusText   = document.getElementById('status-text');

  function altitudeFromPressure(p_hpa, qnh_hpa) {
    // Same formula as your Python: 44330*(1-(p/qnh)^0.1903) in meters, then ft
    if (!p_hpa || !qnh_hpa || p_hpa <= 0 || qnh_hpa <= 0) return null;
    const alt_m = 44330.0 * (1.0 - Math.pow(p_hpa / qnh_hpa, 0.1903));
    const alt_ft = alt_m * 3.28084;
    return Math.round(alt_ft);
  }

  function redrawLabel() {
    let qnh = parseFloat(qnhInput.value);
    if (isNaN(qnh)) qnh = 1013.25;

    const altFt = altitudeFromPressure(lastPressure, qnh);

    const showReg  = showRegBox.checked;
    const showSpd  = showSpdBox.checked;
    const showAlt  = showAltBox.checked;
    const showHdg  = showHdgBox.checked;
    const showTemp = showTempBox.checked;

    const jsSpeed = (lastSpeed   === null || lastSpeed   === undefined) ? null : Math.round(lastSpeed);
    const jsAlt   = (altFt       === null || altFt       === undefined) ? null : Math.round(altFt);
    const jsHdg   = (lastHeading === null || lastHeading === undefined)
                    ? null : (Math.round(lastHeading) % 360);
    const jsTemp  = (lastTempC   === null || lastTempC   === undefined) ? null : Math.round(lastTempC);

    updateLabel(showReg, showSpd, showAlt, showHdg, showTemp,
                jsSpeed, jsAlt, jsHdg, jsTemp);
  }

  // Watch UI changes
  qnhInput.addEventListener('input', redrawLabel);
  [showRegBox, showSpdBox, showAltBox, showHdgBox, showTempBox]
    .forEach(el => el.addEventListener('change', redrawLabel));

  // Follow-Me checkbox logic
  followMeBox.addEventListener('change', () => {
    followEnabled = followMeBox.checked;

    // If we have GPS and follow is turned on, immediately pan once
    if (followEnabled && lastHasGPS && lastLat !== null && lastLon !== null) {
      map.panTo([lastLat, lastLon]);
    }

    // Update status text same way as 'G' key does
    if (!statusText.textContent.startsWith('No Signal')) {
      statusText.textContent = 'Connected' + (followEnabled ? ' (Following)' : '');
      statusText.style.color = 'lime';
    }
  });

  // Line Tracking checkbox logic
  showTrackBox.addEventListener('change', () => {
    updateTrackVisibility();

    // If just enabled and we have a line, zoom to it
    if (showTrackBox.checked && trackLine) {
      map.fitBounds(trackLine.getBounds(), { padding: [20, 20] });
    }
  });

  // Status updates (watchdog, same 2s timeout)
  setInterval(() => {
    const now = Date.now() / 1000;
    const silent = (now - lastRxTime) > 2.0;
    if (silent) {
      if (!statusText.textContent.startsWith('No Signal')) {
        statusText.textContent = 'No Signal';
        statusText.style.color = 'orange';
      }
    }
  }, 500);

  // Keyboard shortcuts: only 'G' (follow) is practical in web
  window.addEventListener('keydown', (ev) => {
    if (ev.key === 'g' || ev.key === 'G') {
      followEnabled = !followEnabled;
      // keep checkbox in sync
      followMeBox.checked = followEnabled;

      if (!statusText.textContent.startsWith('No Signal')) {
        statusText.textContent = 'Connected' + (followEnabled ? ' (Following)' : '');
        statusText.style.color = 'lime';
      }
    }
  });

  // ========= MQTT over WebSocket (HiveMQ Cloud) =========
  const MQTT_URL   = "wss://1c23734948264e8cbc15a03ab2e7e8dc.s1.eu.hivemq.cloud:8884/mqtt";
  const MQTT_TOPIC = "aircraft/OMRJ/telemetry";

  const client = mqtt.connect(MQTT_URL, {
    username: "HTML1",
    password: "David@20071",
    clientId: "ground-station-web-" + Math.random().toString(16).slice(2, 10),
    clean: true,
    reconnectPeriod: 2000, // ms
    keepalive: 30
  });

  client.on('connect', () => {
    console.log("[MQTT] connected");
    client.subscribe(MQTT_TOPIC, { qos: 1 }, (err) => {
      if (err) {
        console.error("[MQTT] subscribe error:", err);
        statusText.textContent = "Subscribe Error";
        statusText.style.color = "red";
      } else {
        statusText.textContent = "Connected" + (followEnabled ? " (Following)" : "");
        statusText.style.color = "lime";
      }
    });
  });

  client.on('reconnect', () => {
    console.log("[MQTT] reconnecting...");
  });

  client.on('error', (err) => {
    console.error("[MQTT] error:", err);
    statusText.textContent = "MQTT Error";
    statusText.style.color = "red";
  });

  client.on('close', () => {
    console.log("[MQTT] connection closed");
    if (!statusText.textContent.startsWith("No Signal")) {
      statusText.textContent = "Disconnected";
      statusText.style.color = "orange";
    }
  });

  client.on('message', (topic, payload) => {
    try {
      const s = payload.toString().trim();
      console.log("[MQTT] msg:", topic, s);
      const parts = s.split(/\s+/);

      let heading   = null;
      let tempC     = null;
      let press_hpa = null;
      let lat       = null;
      let lon       = null;
      let speed_kph = null;
      let has_gps   = false;

      if (parts.length === 6) {
        // H T P LAT LON SPD  (same as PyQt)
        heading   = parseInt(parts[0], 10);
        tempC     = parseInt(parts[1], 10);
        press_hpa = parseFloat(parts[2]);
        lat       = parseFloat(parts[3]);
        lon       = parseFloat(parts[4]);
        speed_kph = parseInt(parts[5], 10);
        has_gps   = true;
      } else if (parts.length === 3) {
        // H T P
        heading   = parseInt(parts[0], 10);
        tempC     = parseInt(parts[1], 10);
        press_hpa = parseFloat(parts[2]);
        has_gps   = false;
      } else {
        // unknown format -> ignore
        return;
      }

      if (isNaN(heading))   heading   = null;
      if (isNaN(tempC))     tempC     = null;
      if (isNaN(press_hpa)) press_hpa = null;
      if (isNaN(lat))       lat       = null;
      if (isNaN(lon))       lon       = null;
      if (isNaN(speed_kph)) speed_kph = null;

      lastRxTime  = Date.now() / 1000;
      lastHeading = heading;
      lastPressure= press_hpa;
      lastTempC   = tempC;
      lastSpeed   = has_gps ? speed_kph : null;
      lastHasGPS  = has_gps;
      lastLat     = lat;
      lastLon     = lon;

      if (has_gps && lat !== null && lon !== null) {
        setAircraft(lat, lon);

        // Add this point to the historical track
        addTrackPoint(lat, lon);

        if (followEnabled) {
          map.panTo([lat, lon]);
        }
      }

      // refresh label with new values
      redrawLabel();

      // Update track if it's visible and we just got first points
      updateTrackVisibility();

      // if we were in "No Signal", flip to "Connected"
      if (!statusText.textContent.startsWith("Connected")) {
        statusText.textContent = "Connected" + (followEnabled ? " (Following)" : "");
        statusText.style.color = "lime";
      }
    } catch (e) {
      console.error("[MQTT] parse error:", e);
    }
  });
</script>
</body>
</html>
